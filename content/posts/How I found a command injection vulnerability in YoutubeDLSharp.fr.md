---
title: "Comment J'ai Découvert une Vulnérabilité D'injection de Commande dans YoutubeDLSharp"
date: '2025-06-13T14:39:16-04:00'
tags: ["cve","c#"]
comments: true
description: "Un « heureux » accident connu sous le nom de GHSA-2jh5-g5ch-43q5, alias CVE-2025-43858."
searchHidden: false
---
Voici l'histoire de mon premier rapport de vulnérabilité. C'était un peu une découverte « accidentelle », mais après réflexion, je pense que ça vaut quand même la peine d'en parler.  
Avant d'aller droit au but, un peu de contexte.
## Contexte
J'ai commencé à écrire mon propre projet C# ([OngakuVault](https://github.com/kitsumed/OngakuVault)) pour automatiser l'archivage de fichiers audio vers mon stockage distant. J'en avais assez de devoir me connecter en SFTP/SSH et de réactiver toutes les sécurités à chaque déconnexion. C'est comme ça que j'ai commencé mon application API ASP.NET, conçue pour être accessible via le web. Pour récupérer les contenus média, j'ai choisi d'utiliser [yt-dlp](https://github.com/yt-dlp/yt-dlp) car c'est un peu un couteau suisse : il supporte plein de sites et formats (appelés « extracteurs »), ainsi que des URLs directes.  
Je ne voulais pas écrire mon propre wrapper (perte de temps, et je ne savais vraiment par où commencer) pour communiquer avec l'éxécutable externe. J'ai donc cherché une library  open-source, et parmi tous les résultats, [YoutubeDLSharp](https://github.com/Bluegrams/YoutubeDLSharp) était la meilleure que j'ai trouvée.

## Le début
J'ai toujours eu un certain intérêt pour la sécurité en informatique, sans être un expert, mais j'ai regardé quelques YouTubers comme [Low Level](https://www.youtube.com/@LowLevelTV) et lu [des blogs](https://mksben.l0.cm/2020/10/discord-desktop-rce.html) sur des découvertes de vulnérabilités. C'est pourquoi, quand j'ai décidé d'utiliser **YoutubeDLSharp**, j'ai fait quelque chose que beaucoup de développeurs dise en blaque : J'ai lu tout le code source. Je n'ai pas forcément tout compris ni passé tout mon temps à le décortiquer, ce n'était pas le but. Je voulais juste m'assurer qu'il n'y avait rien de malveillant.

*Ai-je trouvé quelque chose de malveillant* ? **Non**. Mais une partie du code me donnais un sentiment étrange. J'ai eu un drôle de pressentiment, et c'est justement cette partie qui allait plus tard devenir **[CVE-2025-43858](https://www.cve.org/CVERecord?id=CVE-2025-43858)**. Mais à ce moment-là, je n'y ai pas trop prêté attention. Après plus d'une heure de lecture, j'étais fatigué et **il n'y avait aucune mention ni recommandation de faire de la vérification des inputs nous-mêmes dans le README**. La bibliothèque étant justement un wrapper fait pour communiquée avec yt-dlp, je me suis dit "***Ils doivent sûrement gérer ça de manière sûre***".  
**Spoiler**: *Non :)*.

## Quelques mois plus tard - La découverte  
Quelques mois plus tard, pendant que je travaillait sur mon projet, en debugant les interactions avec le wrapper YoutubeDLSharp, j'ai vu grâce à [Sysinternals Process Explorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer) sur mon second écran que **yt-dlp était lancé par une invite de commande**. (*Je suis sûr que certains comprennent déjà ou je m'en vais avec ça*). La simple vue du processus `cmd` m'a rappelé ce drôle de sentiment que j'avais eu en lisant le code.

À ce moment précis, sans trop savoir pourquoi, j'ai arrêté de déboguer et j'ai eu envie d'envoyer bêtement des requêtes GET à mon application avec des URLs forgées. Ces URLs étaient traitées par mon application puis données au wrapper YoutubeDLSharp qui lançait l'éxécutable yt-dlp. Après environ 8 minutes à essayer différentes URLs, j'ai écrit `https://example.com/" & start calc.exe` et appuyé sur Entrée une dernière fois. **Mon application a planté**. En regardant les logs du débogueur Visual Studio, je me suis demandé : "*Est-ce que je gère mal les exceptions d'URL ?*", mais cette pensée a vite été remplacée par : "**Attends, pourquoi calc.exe est ouvert dans ma barre des tâches ?**".

**Je venais de faire une injection de commande**.

Pour être honnête, je ne me souviens plus de l'exception exacte de mon application, et je n'ai jamais réussi à la reproduire. Je ne comprenais pas pourquoi elle plantait complètement alors que tout était dans un `try-catch`. **Ce que j'ai pu reproduire, en revanche, c'est la création d'URLs forgées « malicieuses » pour injecter des commandes dans le cmd**. Quand j'en ai pris conscience, j'étais surtout content. Je me suis amusé localement à enregistrer quelques PoCs marrants qui ouvraient des vidéos "memes".

Mais j'étais aussi très embêté. Mon application, censée **être accessible à distance via une interface web et une API**, pouvait être complètement compromise avec une simple requête GET. Je savais que c'était grave, **très grave**.

### PoC
```c#
using YoutubeDLSharp;

public async Task<RunResult<VideoData>> GetMediaInformation()
{
        YoutubeDL youtubeDl = new YoutubeDL();
	// Fetch media information using a badly crafted "url" (escaped)
	return await youtubeDl.RunVideoDataFetch("https://example.com/\" & start calc.exe");
}
```
Voici une capture d'écran d'un exemple où `calc.exe` a été remplacé par `msinfo32`.
![showcase](https://github.com/user-attachments/assets/d6f5513c-a69b-4cdd-9820-3f4d71b5c457)

## Empêcher l'exploitation
Une de mes premières idées fut de reporter le problème au propriétaire (**[alxnull](https://github.com/alxnull)**). Mais le dépôt GitHub de **YoutubeDLSharp** était peu actif et le propriétaire peu présent. J'ai donc d'abord fait un fix pour mon propre usage. J'ai identifié les deux caractères qui permettaient l'exploitation de la vulnérabilité : `"` et `&`.

- Le caractère `"` dans l'invite de commande sert à délimiter du texte : `"Mon Texte"`.  
- Le caractère `&` sert à exécuter plusieurs commandes en une seule instruction : `echo Salut & echo Ça va !` lancerait les deux commandes l'une après l'autre.

Je me suis alors demandé s'il était possible de remplacer ces deux caractères dans les URLs, **SANS casser l'URL** (sans la rendre invalide).  
**Oui, c'est possible** grâce à **l'encodage URL**, aussi appelé **[percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding)**. L'encodage URL transforme une liste spécifique de caractères, incluant `"` et `&`, en valeurs `%??`.

J'ai cherché les méthodes existantes d'encodage URL en C# et j'ai décidé que la meilleure façon était de convertir ma chaîne d'URL en un type [Uri](https://learn.microsoft.com/en-us/dotnet/api/system.uri?view=net-8.0) qui a une propriété encodée avec le percent-encoding.

**Le fix était né** :
```c#
public static string? SanitizeUrl(string url)
{
	// Parse the URL using Uri
	if (Uri.TryCreate(url, UriKind.Absolute, out Uri? urlUri))
	{
		// According to the microsoft docs getting the absolute url append
		// all of the others fields, theses fields get URI escaped when you GET them
		// (https://learn.microsoft.com/en-us/dotnet/api/system.uri.query?view=net-8.0#remarks) 
		return urlUri.AbsoluteUri;
	}
	// Invalid url format
	return null;
}
```
Avec cette méthode, l'URL forgée `https://example.com/" & start calc.exe` devient `https://example.com/%22%20&%20start%20calc.exe`, ce qui empêche l'exploitation de la vulnérabilité.

Même si ce code règle le problème des URLs forgées dans mon application, il faut noter que théoriquement (je ne l'ai pas testé), les options passées en arguments aux commandes *(exemple : `-myArg "patate"`)* lors de l'appel à yt-dlp pourraient aussi être exploitées, **et l'encodage URL ne vous protégerait pas contre ça**.

**Et même si ça fonctionnait, ça causerait probablement plus de problèmes**. C'est pourquoi, en rédigeant le rapport de vulnérabilité, j'ai jeté un coup d'oeil rapide au code source et trouvé un moyen de mitiger complètement le problème au prix d'une perte de fonctionnalité (fonctionnalité que **alxnull** m'a dit plus tard ne pas être vraiment nécessaire).

Je ne rentrerai pas dans les détails, mais la mitigation complète était assez simple. Le seul inconvénient était de ne plus pouvoir utiliser de méthodes « user-friendly » et de devoir gérer le wrapper à un niveau plus « bas » :
```c#
YoutubeDLProcess youtubeDLProc = new YoutubeDLProcess()
{
    // That's the important part!!! No more funny cmd starting yt-dlp
    UseWindowsEncodingWorkaround = false 
};
```

## Signaler la vulnérabilité  
Signaler la vulnérabilité fut un défi en soi. J'avais lu sur la [fonctionnalité GitHub Advisories](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability) mais elle était désactivée sur son dépôt. J'étais mélanger sur la marche à suivre et ne trouvais pas comment le contacter. J'ai fini par trouver un email dans l'une de ses organisations et l'ai utilisé pour lui demander d'activer la fonction GitHub Advisories. Ce mail contenait les instructions pour me répondre. Je n'ai jamais eu de réponse, mais environ 3 à 4 semaines après l'envoi, j'ai constaté que la fonctionnalité était activée. Est-ce que j'es manquée un courriel réponse ou est-ce qu'il ne ma jamais répondu ? Je n'en sais rien.

J'ai poursuivi en créant le rapport advisory et [localisé les lignes exactes dans le commit](https://github.com/Bluegrams/YoutubeDLSharp/commit/fdf3256da18d0e2da4a2f33ad4a1b72ff8273a50#diff-8ec44b4ade6ce6ed38ebf7e765dc86c426984a18304cd1cd320bf92500133c88R107) qui introduisaient le bug. Je me souviens aussi avoir été un peu perdu en faisant le score CVSS. Au début, j'essayais de faire un CVSS v4, mais certaines catégories étaient trop compliquées, et la v3 en avait moins, donc j'ai pris celle-là 👍.

La vulnérabilité a fini classée **9.2 critique**, la bibliothèque n'étant pas très populaire, donc je doute que cette découverte ait eu un impact « global » important.  
J'ai ensuite découvert les **CWE** (***Common Weakness Enumerator***). D'après ce que j'ai compris, ce sont des listes d'erreurs courantes menant à des vulnérabilités. On peut les référencer dans un rapport, donc j'ai référencé :
- `CWE-77` (***Neutralisation incorrecte d'éléments spéciaux utilisés dans une commande***)  
- `CWE-78` (***Neutralisation incorrecte d'éléments spéciaux utilisés dans une commande système***)  
- `CWE-20` (***Validation incorrecte des entrées***).

Après réflexion, je ne pense pas que `CWE-20` s'applique ici (il n'y avais pas de validation). Il semble aussi qu'elle soit manquante dans le [record CVE](https://www.cve.org/CVERecord?id=CVE-2025-43858).

Une fois mon rapport terminé, j'ai attendu. Comme je n'étais pas sûr que le propriétaire soit encore actif, j'ai mentionné dans les commentaires le **2025-02-23** que j'attendrais environ 3 semaines un signe de vie, et si je n'en avais pas, je publierais une copie du rapport publiquement.

J'ai fait ça car mon propre projet avait déjà un commit avec le fix, et publier mon projet rendrait la vulnérabilité « publique », donc je l'ai gardée privée. Cependant, après 3 semaines, j'ai trouvé que c'était trop court et j'ai décidé d'attendre encore. Le **2025-03-26**, j'en ai eu assez et j'ai décidé de [la rendre publique via une issue](https://github.com/Bluegrams/YoutubeDLSharp/issues/68). J'ai aussi mis à jour le rapport advisory privé pour avertir l'owner du dépôt.

Le **2025-04-22**, j'ai eu le premier signe de vie du propriétaire, **alxnull**. Le [rapport advisory a été accepté](https://github.com/Bluegrams/YoutubeDLSharp/issues/68#issuecomment-2822152155). Peu après, un commit a été fait, corrigeant le problème en supprimant complètement **UseWindowsEncodingWorkaround** dans la version ``v1.1.2``. L'advisory a ensuite été publié sur GitHub le **2025-04-23** sous le nom **GHSA-2jh5-g5ch-43q5**, et le **2025-04-24** elle a été accepté dans la base de donnée CVE sous le nom **CVE-2025-43858**.

Voilà qui conclut mon histoire. Si vous voulez lire le rapport CVE complet, avec un peu plus de détails sur le code qui causait la vulnérabilité, vous pouvez le trouver [ici](https://github.com/advisories/GHSA-2jh5-g5ch-43q5). N'hésitez pas à laisser un commentaire si vous avez des recommandations, par exemple sur la façon dont j'aurais dû gérer la publication du rapport après les 3+ semaines.
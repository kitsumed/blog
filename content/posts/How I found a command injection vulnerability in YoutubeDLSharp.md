---
title: 'How I Found a Command Injection Vulnerability in YoutubeDLSharp'
date: '2025-06-13T14:39:16-04:00'
tags: ["cve","c#"]
comments: true
description: "A \"happy\" accident now know as GHSA-2jh5-g5ch-43q5, aka CVE-2025-43858."
searchHidden: false
---
This is the story of my first vulnerability report. It was kind of an 'accidental' discovery, but after thinking about it, I think it's still worth writing about.
Before going straight to the interesting stuff, let's get some context
## Context
I started writing my own C# project ([OngakuVault](https://github.com/kitsumed/OngakuVault)) to automate archiving audio files into my remote storage. I had grown tired of connecting using SFTP/SSH and re-enabling all security every time I had to disconnect. That's how I started my ASP.NET API application, it is meant to be accessible through the web. For the task of actually getting the media content, I decided to use [yt-dlp](https://github.com/yt-dlp/yt-dlp) as it is a bit like a Swiss knife. It supports a lot of websites and formats (known as 'extractors'), along with direct URLs. That said, I didn't really want to write my own wrapper (as I would lose time, and I wasn't even fully sure where to start) to communicate with the external binary. Instead, I searched online for existing open-source libraries, and out of all the results, [YoutubeDLSharp](https://github.com/Bluegrams/YoutubeDLSharp) was the best one I could find.

## The beginning
I've always had some interest in software security and cared about it to a certain extent. Nothing really big, but I did watch some YouTubers like [Low Level](https://www.youtube.com/@LowLevelTV) and read [some blogs](https://mksben.l0.cm/2020/10/discord-desktop-rce.html) about other people's findings. That's why when I settled on using **YoutubeDLSharp**, I did something most developers often joke about. I've read all the source code. Now, I didn't necessarily understand everything and didn't take all of my time to read it in detail. It wasn't my intention. I was looking to ensure there wasn't anything malicious.

*Did I find anything malicious*? **No**. But one part of the code did "trigger" me. I had a weird feeling, and it was the very part that would later turn into **[CVE-2025-43858](https://www.cve.org/CVERecord?id=CVE-2025-43858)**. But at that time, I didn't think much of it. After reading the code for around more than 1 hour, I was tired, and **there was no mention or recommendation of doing sanitisation ourselves in the README**. The library being a wrapper written for that exact purpose, I thought "***Surely, they are handling this in a safe manner***".
**Spoiler**: *It wasn't*.

## A couple of months later - The discovery
Fast forward to a couple of months later when I started working on my project again. While debugging my application's interactions with the YoutubeDLSharp wrapper, I noticed through the [Sysinternals Process Explorer](https://learn.microsoft.com/en-us/sysinternals/downloads/process-explorer) running on my side monitor that **yt-dlp was started by a Command Prompt**. (*I'm sure some of you already know where this is going*). The simple sight of the cmd process made me remember the weird feeling I had while checking the source code.

At that very moment, for some reason I couldn't really explain, I stopped debugging my application and felt the urge to start mindlessly sending GET requests to my application endpoint with forged URLs. These forged URLs were then handled by my application and given to the YoutubeDLSharp wrapper, which was in charge of calling the yt-dlp binary. After around 8 minutes of trying different forged URLs, I wrote `https://example.com/" & start calc.exe` and hit enter one more time. **My application crashed**. When I saw the Visual Studio debugger logs, I thought, "*Huh, am I handling URL exceptions wrong?*", but that thought was quickly followed by "**Hold on, why is calc.exe open in my taskbar**?".

**I had found a command injection vulnerability**.

To be honest, I don't remember what my application's exception was, and I was never able to replicate it. I remember not understanding why it fully crashed, as everything was happening inside a `try-catch` statement. **What I was able to replicate, however, was creating the forged "malicious" URLs to inject commands inside the cmd**. Now, when I first came to that realization, I was mostly happy. I started having fun with it locally, recording some funny PoCs that opened meme videos.

While I was happy, I was also very annoyed. My application, which is intended to **be accessible remotely by using a web interface and API**, could be fully compromised with one GET request. I knew this was bad, **really bad**.

### PoC
```c#
using YoutubeDLSharp;

public async Task<RunResult<VideoData>> GetMediaInformation()
{
        YoutubeDL youtubeDl = new YoutubeDL();
	// Fetch media information using a badly crafted "url" (escaped)
	return await youtubeDl.RunVideoDataFetch("https://example.com/\" & start calc.exe");
}
```
Here's a screenshot of an example where `calc.exe` was replaced with `msinfo32`.
![showcase](https://github.com/user-attachments/assets/d6f5513c-a69b-4cdd-9820-3f4d71b5c457)

## I made a workaround
One of my very first thoughts was to report the issue to the owner (**[alxnull](https://github.com/alxnull)**). But the **YoutubeDLSharp** GitHub repo was rarely active and the owner had low activity. Thus, I decided to first make a workaround for my own application. I looked at the two characters that allowed all of this to happen, `"` and `&`.

- The `"` character in the command prompt is used to represent text: `"My Text"`.  
- The `&` character is used when you want to run multiple commands in a single instruction: `echo Hi & echo There!` would run both commands one after another.

I then wondered, could I replace these two characters in URLs, WITHOUT damaging the URL? (Without making it invalid). **Yes, I could**, using **URL encoding**, also known as **[percent-encoding](https://en.wikipedia.org/wiki/Percent-encoding)**. URL encoding turns a specific list of characters, including `"` and `&`, into `%??` values.

I looked up existing methods for URL encoding in C# and decided the best way of doing it would be to convert my URL string into a [Uri](https://learn.microsoft.com/en-us/dotnet/api/system.uri?view=net-8.0) type that contained a property with the URL encoded using percent-encoding.

**The workaround was born** :
```c#
public static string? SanitizeUrl(string url)
{
	// Parse the URL using Uri
	if (Uri.TryCreate(url, UriKind.Absolute, out Uri? urlUri))
	{
		// According to the microsoft docs getting the absolute url append
		// all of the others fields, theses fields get URI escaped when you GET them
		// (https://learn.microsoft.com/en-us/dotnet/api/system.uri.query?view=net-8.0#remarks) 
		return urlUri.AbsoluteUri;
	}
	// Invalid url format
	return null;
}
```
Using this method, the forged URL `https://example.com/" & start calc.exe` would turn into `https://example.com/%22%20&%20start%20calc.exe`, effectively preventing the exploitation of the vulnerability.

While this workaround fixed the issue of forged URLs for my application, it is important to note that theoretically (I didn't test it) the options that get added to the commands as argument values *(Example: `-myArg "potato"`)* when calling yt-dlp could also be exploited, **and URL encoding would not save you from that**.

**Even if they did, it would probably causes more issues**. That's why while writing the vulnerability report, I took another quick look at the source code and found a way to fully mitigate the issue at the loss of some fonctionality (fonctionality that the owner later told me wasn't actually nessesary).

I won't go into details as to what the full mitigation is, but is was fairly simple. The only downside was that you couln't use any "user-friendly" method and had to handle the wrapper fully at a more "low" level :
```c#
YoutubeDLProcess youtubeDLProc = new YoutubeDLProcess()
{
    // That's the important part!!! No more funny cmd starting yt-dlp
    UseWindowsEncodingWorkaround = false 
};
```

## Reporting the vulnerability
Reporting the vulnerability was a challenge itself. I had read about the [GitHub Advisories feature](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability) but it was disabled on his repository. I was conflicted on what to do, and started looking up his profile. I ended up finding an email in one of his organizations and used it to ask him to enable the feature. That email had instructions on how to notify me back. I never got any answer, but at some point (around 3 to 4 weeks after sending the mail) I found out that the feature was now enabled. Was it me who didn't look properly or did he never responded? Truth is, I still have no clue.

I proceeded with creating the advisory report and [located the exact lines in the commit](https://github.com/Bluegrams/YoutubeDLSharp/commit/fdf3256da18d0e2da4a2f33ad4a1b72ff8273a50#diff-8ec44b4ade6ce6ed38ebf7e765dc86c426984a18304cd1cd320bf92500133c88R107) that introduced the bug. I remember also getting confused when making the CVSS score. At first, I was trying to do a CVSS v4 but some categories were too confusing, and v3 had fewer, so I took that one üëç.

It ended up being ranked a **9.2 critical**, although, the library being not that popular, I doubt this discovery had any major impact "globally".  
I then discovered **CWE** (***Common Weakness Enumerator***). From my understanding, they are lists of common errors that lead to vulnerabilities. These can be referenced when making a report, so I referenced:
- `CWE-77` (***Improper Neutralization of Special Elements used in a Command***)
- `CWE-78` (***Improper Neutralization of Special Elements used in an OS Command***)
- `CWE-20` (***Improper Input Validation***).

After thinking about it again, I don't think `CWE-20` really apply in this case (there is no validation at all). It seems it is also missing from the [CVE record](https://www.cve.org/CVERecord?id=CVE-2025-43858).

Once my report was done, I waited. As I was unsure if the owner was still active, I mentioned on **2025-02-23** in the comments that I would wait around 3 weeks for a sign of life, and if I didn't get any, I would post a copy of the report publicly.

I did this as my own project already had a commit with the fix, and releasing my project would make it "public" at the same time, so I kept it private. However, after the 3 weeks I still felt I had waited too short an amount of time, so I decided to wait. On **2025-03-26** I had enough and decided to [make it public in an issue](https://github.com/Bluegrams/YoutubeDLSharp/issues/68). I updated the private advisory report to also warn of this.

On **2025-04-22** I had the first sign of life from the owner, **alxnull**. The [advisory report was accepted](https://github.com/Bluegrams/YoutubeDLSharp/issues/68#issuecomment-2822152155). Shortly after, a commit was made, fixing the issue by fully removing **UseWindowsEncodingWorkaround** in version ``v1.1.2``. The advisory was then published on GitHub on **2025-04-23** under the name **GHSA-2jh5-g5ch-43q5**, and on **2025-04-24** it was accepted into the CVE database as **CVE-2025-43858**.

That concludes my story. If you want to read the full CVE report, with a bit more detail on the code that caused the vulnerability, you can find it [here](https://github.com/advisories/GHSA-2jh5-g5ch-43q5). Feel free to leave a comment if you have any recommendations on how I should have handled making the report public for example.
